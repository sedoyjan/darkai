Project Summary: DarkAI Sway
Main Idea
DarkAI Sway is a React Native mobile application designed to provide users with strategic, "dark" advice through a chat-based AI assistant. The app aims to help users achieve their goals by offering cunning, tactical suggestions in a playful, mischievous tone (e.g., "How’s your master plan going? "). The primary focus is on user engagement and retention, with features like a freemium model, follow-up messages to re-engage inactive users, and push notifications to bring users back to the app. The app is built with a modern tech stack, leveraging React Native for the frontend, Elysia for the backend, Prisma for database management, and OpenAI for AI-driven chat responses.
Product Details
Core Functionality:
Chat Interface: Users can start a chat with an AI assistant to get strategic advice on various topics (e.g., "How to convince my boss for a raise?").

Freemium Model: Users get 4 free messages before being prompted to subscribe. This is enforced by tracking requestsCount in the user model and blocking further messages if the limit is exceeded without a subscription.

Follow-Up Messages: To improve user retention, the app sends follow-up messages to inactive users after 24–48 hours of inactivity. These messages are generated by a dedicated OpenAI assistant and ask about the user’s progress or achievements (e.g., "How’s your plan to impress the boss going? ").

Push Notifications: Follow-up messages are accompanied by push notifications to re-engage users, including deep links to the specific chat.

User Experience:
The app has a dark, strategic theme with a playful tone, reflected in the assistant’s responses and UI elements (e.g., use of  emoji).

Chats are created only after the user sends their first message, reducing unnecessary data in the database.

The welcome message ("Привет! Я твой Тёмный консультант. Задай мне цель, и я помогу её достичь! ") is added dynamically via a Redux selector, not stored in the database.

Users can view a list of chats, delete chats, and receive notifications about new messages.

Retention Strategy:
Follow-up messages are sent to users who haven’t responded in 24–48 hours, with a limit of 2 follow-ups per chat to avoid spamming.

Push notifications are sent via Firebase Cloud Messaging (FCM) with deep links to the chat screen (e.g., /(tabs)/(chats)/${chatId}?title=${chatTitle}).

Technical Details
Frontend:
Framework: React Native with Expo.

Routing: expo-router for navigation. Routes are structured as /(tabs)/(chats)/[chatId], where chatId is a dynamic parameter, and query parameters like title are used for chat titles.

State Management: Redux Toolkit for managing chat state (chatsMap, isBotTyping, isLoading, etc.).

Storage: AsyncStorage (from @react-native-async-storage/async-storage) for persisting the messageCount for the freemium model, replacing localStorage (which isn’t available in React Native).

UI Components: React Native components (View, Text, TextInput, TouchableOpacity, ScrollView) with styles defined using StyleSheet.

Custom Hook: useChat manages chat logic, including sending messages, initializing chats, and handling freemium limits.

Selectors: makeSelectChatMessages dynamically adds the welcome message if the chat is empty and handles special messages (e.g., "bot-typing", "out-of-free-messages").

Backend:
Framework: Elysia (a lightweight Bun-based framework) for the API.

Database: Prisma ORM with a PostgreSQL database (assumed based on typical Prisma usage).

Database Schema:
Chat model: id, userId, title, threadId, updatedAt, messages, lastFollowUpSentAt, followUpCount.

Message model: id, text, type (USER, BOT, SYSTEM), createdAt, userId, chatId.

User model: id, requestsCount, hasActiveSubscription, pushToken.

API Endpoints (ChatController):
POST /chat/sendMessage: Creates a new chat if it doesn’t exist, saves the user’s message, generates a bot response via OpenAI, and updates requestsCount.

GET /chat/getMessages: Retrieves messages for a specific chatId with pagination.

GET /chat/getChats: Lists all chats for a user with the last message for preview.

GET /chat/getChat: Retrieves details of a specific chat.

DELETE /chat/deleteChat: Deletes a chat by chatId.

Middleware: isAuthenticated ensures only authenticated users can access chat endpoints. A freemium check in onBeforeHandle blocks users who exceed the free message limit (4 messages) without a subscription.

Debug Endpoint: GET /debug/follow-up in DebugController to manually trigger the follow-up flow for testing.

AI Integration:
OpenAI API: Used for generating bot responses and follow-up messages.

Main Assistant: generateDarkAIStrategy (assumed to be a function calling OpenAI) generates responses for user messages.

Follow-Up Assistant: A dedicated OpenAI assistant (DarkAI_FollowUp_Assistant) is configured in the OpenAI Dashboard with instructions to generate re-engagement messages based on the last 2–4 messages in a chat. Instructions include:
Tone: Friendly, encouraging, slightly playful with a "dark" vibe.

Length: Up to 100 characters.

Examples: "Hey, how’s your plan to impress the boss going? "

Follow-Up Logic: Implemented in generateFollowUpMessage, which uses the OpenAI Threads API to interact with the follow-up assistant.

Push Notifications:
Service: Firebase Cloud Messaging (FCM) for sending push notifications.

APNs Setup: An APNs auth key (.p8 file) is generated in the Apple Developer Portal (under Certificates, Identifiers & Profiles > Keys) and uploaded to Firebase Cloud Messaging settings with the Key ID and Team ID.

Implementation: sendPushNotification sends notifications using the Expo Server SDK, including deep links to the chat screen.

Push Token: Stored in the User model as pushToken for sending notifications to specific users.

Follow-Up Flow (Debug Implementation):
Endpoint: GET /debug/follow-up checks all chats for inactivity.

Logic: If a chat has no messages for 24 hours and hasn’t reached the follow-up limit (2 messages), a follow-up message is generated and sent.

Message Generation: Uses generateFollowUpMessage to create a message based on the last 2–4 messages.

Storage: Follow-up messages are saved as BOT messages in the database, and the chat is updated with lastFollowUpSentAt and followUpCount.

Notification: A push notification is sent with the follow-up message text and a deep link to the chat.

Key Features and Flows
Chat Creation:
Chats are created only after the user sends their first message (via /sendMessage or useChat).

The welcome message is added dynamically via a Redux selector (makeSelectChatMessages).

Freemium Model:
Users get 4 free messages (requestsCount incremented on each message).

After 3 messages, a warning is shown ("Осталось 1 бесплатное сообщение!").

After 4 messages, the chat is disabled unless the user has a subscription (hasActiveSubscription).

Follow-Up Messages:
Sent after 24 hours of inactivity (configurable).

Limited to 2 follow-ups per chat.

Generated by a dedicated OpenAI assistant with a playful, strategic tone.

Accompanied by push notifications with deep links.

Navigation:
Uses expo-router with routes like /(tabs)/(chats)/[chatId]?title=${title}.

useLocalSearchParams<ChatRouteParams> extracts chatId and title with TypeScript typing.

Current Development Focus
Follow-Up Flow: You’re currently implementing a follow-up system to improve user retention. The flow is being tested via a debug endpoint (/debug/follow-up) before being moved to a Cron Job.

Push Notifications: APNs auth key has been set up in Firebase, and push notifications are implemented for follow-up messages.

OpenAI Assistant: A follow-up assistant is configured in the OpenAI Dashboard to generate re-engagement messages.

Potential Next Steps for Development
Cron Job Implementation:
Move the follow-up logic from DebugController to a Cron Job using node-cron to automate the process (e.g., check every hour).

Add logging to track sent follow-ups and user responses.

Client-Side Enhancements:
Update useChat to handle push notifications and automatically refresh the chat when the user returns via a deep link.

Add a setting to disable follow-up messages for users who don’t want them.

Analytics:
Track user engagement metrics (e.g., how many users return after a follow-up message).

A/B test different follow-up intervals (24 vs. 48 hours) and message tones.

Subscription Flow:
Implement a subscription purchase flow to allow users to unlock unlimited messages.

Add an endpoint to reset requestsCount after a subscription purchase.

Error Handling and Scalability:
Add retry logic for failed OpenAI API calls or push notification sends.

Optimize database queries for large numbers of chats (e.g., add indexes on Chat.updatedAt and Message.createdAt).

Localization:
Support multiple languages for the welcome message and follow-up messages (e.g., based on the locale parameter in /sendMessage).

Important Notes for Further Development
Database Optimization: Ensure indexes are set on frequently queried fields (e.g., Chat.userId, Message.chatId) to handle scale.

Push Notification Reliability: Test push notifications on both Development and Production environments to ensure APNs is configured correctly.

User Privacy: Allow users to opt out of follow-up messages and ensure push tokens are securely stored.

OpenAI Costs: Monitor OpenAI API usage for follow-up messages, as generating messages for many inactive users could increase costs.

Testing: Use the /debug/follow-up endpoint to thoroughly test the follow-up flow before automating it with a Cron Job.

